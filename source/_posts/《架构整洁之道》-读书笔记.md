---
title: 《架构整洁之道》-读书笔记
categories: 
    - [架构]

tags: 
    - 读书笔记

excerpt: 作为一个从上世纪70年代就开始从事编程的老牌程序员来说，Uncle Bob最为人所知的是他关于clean code的见解，但他对架构方面的理解也同样很精辟.
---
<a name="4B1fS"></a>
### 组件聚合
组件的发展会经历:

1. 快速发展
1. 沉淀
1. 分离


<br />快速发展阶段，会讲相同/相似，更确切的说是有相关性的功能放在一块.(这个阶段也可以理解为攀亲戚，各种八竿子打不着的都可能会被强扭在一块)。<br />经历快速发展之后，会发现修改一处代码，会有很多相似的代码也需要去修改，一旦遗漏了某处肯能就会出现一个大的故障。此时会将哪些相同的东西抽取出来，形成一个基础的东西，从而增加代码复用性<br />
<br />最后当组件越来越大，发现很多功能是不能在一起的，就会做拆分。在分离/引入依赖的时候，最好做彻底点，不能因为引用了一个类就将那个依赖引进来，这样很容易会发生被依赖方一变动，依赖方必须跟着变动。<br />
<br />所以以上对应的组件构建的三个原则是:

1. CCP: 共同闭包原则 
   1. 将那些会同时修改并且是为相同目的而修改的类放到同一个组件中；将那些不会同时修改，并且不是因为相同目的而修改的类放到不同的组件中
   1. 这个是SRP原则在组件层面的一个阐述. SRP: 单一职责原则
2. REP: 复用/发布等同原则
   1. 一个组件不能由一堆毫无关系的类和模块组成。 而应该是由具有相同目的/功能的类和模块组成
   1. 组件中的类或者模块，在发布的时候大家是一起发布的，不能存在某些可以发布，某些不能发布。即: 软件复用的最小粒度等同于其发布的最小粒度
3. CRP: 共同复用原则
   1. 不要强迫一个组件依赖它们不需要的东西。是ISP(接口分离原则)在组件层面的阐述


<br />

<a name="1TlOQ"></a>
### 组件耦合
项目的程序发展应该是向这么个架构发展: 顶层 到 底层的走向，每走一步都是向更稳定的方向走，即底层是最稳定的，也是最不容易变动的。因为它一变动依赖他的都要跟着变动，代价太大。<br />
<br />那么如果底层既想要稳定又想要有一些高阶的策略设计呢？这就可以将底层设计成抽象类，一部分是稳定的不变的，一部分是抽象方法. 这样依赖它的地方就可以做到扩展，而它自己只是做了一些高阶的设计<br />
<br />

<a name="x94Xs"></a>
### 独立性
系统在设计的时候应该在水平进行分层，垂直也要做一定的切分。这样做了之后会让系统的各个功能之间独立，从而可以在将来拆分出来做一个单独服务出去

- 水平分层，很常见. controller/service/manager/dao的划分就是很常见的一种方式
- 垂直划分，一般都是以业务进行划分。比如创建订单/删除订单


<br />关于重复: 并不是所有的代码重复都是需要被处理的。有时候代码的重复是为了以后业务方向不同而做的，只是暂时的，随着业务发展，重复的代码将会变得很不一样，这种就是表面重复。如果硬将它们写在一起，等到后面业务发展的时候就有很多if/else之类的代码了，越到后面越难切割开了<br />
<br />
<br />解耦的方式有以下几种

- 源代码层的解耦。这种方式下，我们通过控制源码层面上不同模块之间的依赖关系，来达到一个模块的改动不会引起其他模块的改动，常用的是水平/垂直的切分
- 部署上的解耦，将部署隔离开来。比如某个业务/模块形成单独的jar，要发布它只是将其加入到应用程序中，然后重新部署，而不会影响到其他的jar
- 服务层次的解耦，就是常说的微服务。这种是数据结构的解耦，各个服务之间的通信只要知道数据接口就可以了。但微服务一般在设计之处都是以粗粒度进行规划的，可能发展到后面，一个微服务又需要再次进行拆分为多个子微服务



<a name="4PZ1b"></a>
### 策略与层次，关键业务
一个软件系统，处理的是接受输入信息，经过一定的业务逻辑处理，输出结果。架构设计时，要把系统按照离I/O的远近来分层，离I/O越近的其易变性更大，而离I/O越远的则稳定性更强。所以在设计依赖关系时应该让易变性组件依赖稳定性组件，形成一个DAG(有向无环图)，最好是以插件的形式出现。<br />在代码实现的过程中，也尽量按照DAG的方向进行编写归类。<br />
<br />而一个系统中总有某些业务是可以用来赚钱或者省钱，离开它该体统就没有什么价值了，该类业务称之为关键业务，其处理的数据则是关键数据，对应的处理逻辑则为关键逻辑。一般在设计的时候，都应该将它们放在一块(这里的一块并不是说放在一个类中，毕竟如果业务复杂的话，放在一个类中会让代码非常冗长), 我们可以称之为核心域。它应该是离I/O较远的，所以它也应该是较稳定的<br />
<br />

<a name="Ek2Os"></a>
### 架构整洁设计


1. 框架只是实现细节的一部分，不应该影响架构的设计
> 一个系统在设计之初，不应该局限于它要采用哪种框架而应该考虑它是为什么业务而生的，它的用例有哪些？并通过这些用例抽取出核心业务出来。当一个新人来的时候，不应该问系统使用的是何种框架，而应该关心有哪些用例从而快速上手
> 

> 架构师应该在确保当前架构设计满足用例的前提下，尽可能地允许用户能自由的选择建筑材料(石料，砖头或者木材)，在软件行业就是使用哪种框架，哪种类型的存储系统(关系型数据库还是NoSQL数据还是其他的)


<br />一个系统的架构是否整洁，关键看设计开发的时候是否遵循严格的分层原则。尤其是在实现的过程中，对于跨界的处理是否不越界，是否数据流向依然是从低层次指向高层。处理的方式一般是在内层定义接口，然后让外层去实现，以达到解耦的目的<br />![CleanArchitecture.jpg](1.jpg)<br />用例是在关键业务的外围，它们协调指挥关键业务的数据流转从而实现业务目标；而数据库，哪种web技术，展现形态，等等都是易变的，所以它们应该离同心圆很远<br />![image.png](2.png)<br />
<br />

<a name="E4TFf"></a>
### 服务: 宏观与微观
将系统以微服务架构进行设计，在运行一段时候之后，可能会遇到横跨型变更(cross-cutting concern)问题。所谓横跨型变更问题是指，一个需求过来，所有的微服务或者大部分的微服务都需要做变更以适应需求变更。<br />
<br />如果服务之间有耦合的东西，比如它们公用了同一个数据库表，那么数据库表的字段变更了，所有涉及到的微服务都要变更。这其实各个服务之间就不是完全的解耦. 所以一般我们都是一个微服务一个数据库，做到垂直隔离<br />

<a name="CzaTe"></a>
#### 类滴滴系统架构的解耦
对于横跨型变更，如何解决？答案是采用组件化的方式来处理，将不同业务做成不同的组件. 比如一个类似滴滴的系统<br />
<br />初始的架构<br />![image.png](3.png)<br />
<br />应对横跨型变更问题-单体应用的解耦，在架构内部采用组件化架构<br />![image.png](4.png)<br />
<br />
<br />应对横跨型变更问题-微服务的解耦，在各个微服务的内部采用组件化架构<br />![image.png](5.png)<br />
<br />
<br />

<a name="hmxoQ"></a>
### 代码组织架构


<a name="d9GE9"></a>
#### 按层封装
大部分单体应用，在初创期，都是按照controller/service/dao进行分类的. 但是随着业务发展，团队的壮大，会出现直接controller调用dao的情况(即所谓的"宽松分层架构"的出现). 并且这种架构的弊端是找一个业务的相关代码需要找很多地方。如果后期壮大到需要将单体分拆为多个微服务，更是一通好找。<br />![image.png](6.png)<br />

<a name="ZP0wr"></a>
#### 按功能封装
按功能分，就是将功能相关的代码都集中到一个package中，然后里面包含了所有.这种的话，复用是个问题，毕竟对外暴露的是controller，其他诸如service/dao是对外不可见的<br />![image.png](7.png)<br />

<a name="mNvrO"></a>
#### 以业务领域+实现进行分离
采用“端口和适配器”架构，将核心域(业务领域)的东西放到一个package内，将其他具体实现放到其他package；<br />![image.png](8.png)<br />![image.png](9.png)<br />

<a name="jwJIS"></a>
#### 以组件形式封装
最后一种是以组件的形式对外暴露. controller是一个package，其他的都以component的形式对外暴露，类似于facade模式<br />![image.png](10.png)<br />
<br />

<a name="sKMN8"></a>
#### 各个组织形式的对外暴露的形态

<br />以下是各个组织形式下，对外暴露的内容. 其中虚化的是内部对外不可见的类，即非public的<br />![image.png](11.png)<br />
<br />
<br />
<br />


