
---
title: 《领域驱动设计精粹》-读书笔记
categories: 
    - 设计
    - DDD
tags: 
    - 读书笔记
---

<a name="xJ6L8"></a>
### chapter 1: 设计

- 过度设计，毫无设计，都是不可取的；最好的是适度设计，演进式地对设计进行升级改造而不是一蹴而就的
- 闭门造车想出来的产品功能，也是不可取的
- 不是有效设计就是糟糕的设计，不存在什么“毫无设计”一说
- 领域设计中有两个概念
  - 战略设计，是高层次的设计，一般是划分上下文
  - 战术设计，是上下文中实现的设计


<br />
<br />

<a name="7o3tN"></a>
### chapter 2: 限界上下文的定义


1. MVP(Minimum Viable Product)产品原则: 功能最小的产品原则，提倡在产品需求研发过程中聚焦于最小化可行产品上，不断获取用户的反馈并持续迭代。韩国的一些电视剧的拍摄模式就采用类似这样的方式，先拍几集播放出来之后看市场反馈，如果ok则开始写接下来的剧本并拍摄，否则可能就面临砍掉的风险



2. 同时在需求评审过程中，不要过早地提及技术实现细节，毕竟技术是为产品服务的，如果产品功能合理，那么就需要花时间去攻克技术难点。若时间不允许，在评审中可以考虑让产品功能以另外一种方式实现。所以要先了解需求之后再进行技术的评估，不要让技术引导产品的走向(虽然有时候这种方式能带来很好的效果)



3. 限界上下文，这个其实就是领域的概念了. 不同的限界上下文中
  - 他们的仓库一般都是不一样的。即代码各管个的
  - 他们的规范也可能是不一样的，每个限界上下文的规范可能是自成一派.
  - 开发的时候，一般是一个团队负责一个限界上下文，如果其他团队希望来共建，那么也是可以的，但前提是需要遵守该限界上下文中的规范，提交的代码由该限界上下文的负责团队进行review审批



4. 限界上下文的定义过程中
  - 要遵循只有最核心的概念才能归属于该限界上下文，不是核心的不要进来. 否则该限界上下文将会变得非常庞大，最终成为一个大泥球
  - 一个概念要加进来的时候，要去质疑它是否是核心概念？够不够资格？
  - 限界上下文的定义是一个渐进过程，研发人员/测试人员/业务专家(通常是产品)等角色都可能会发现问题，当发现问题的时候最好大家一起当面沟通，提高效率. 毕竟沟通过程中可能会有其他问题迸出来
  - 领域模型的定义，不要跟相关的实现技术糅合在一起，因为领域模型是跟技术无关的，用哪种技术实现都是ok的


<br />

5. 在没有很好划分限界上下文的时候，系统可能就是一个大泥球(Ball of Mud), 之所以这么说是因为系统是有多个没有明确边界并且纠缠在一期的模型组成，类似麻花拧在一块，内部的连线错综复杂。没人敢乱动，也没人想去动


<br />

6. 在进行领域划分的时候，可能会遇到一个术语在不同的领域内表达的含义不一样，这时候就要考虑在每一个领域内都定义一个该术语以清晰的表达业务含义。但需要注意的是，在各自的领域内命名需要遵循正交性，比如在很多地方都有一个叫西湖的，比如
  - 杭州西湖
  - 惠州西湖

但是在在自己领域内(比如在杭州)就没必要说将该湖命名为杭州西湖，直接将其命名为西湖即可。因为它和它所在的领域正交起来就是: 杭州西湖<br />
<br />

7. 只有业务复杂复杂到一定程度的时候才需要考虑使用DDD模式进行开发，如果业务很简单，只有CRUD并且不涉及到其他系统，那么就没有必要使用DDD。否则会增加系统的复杂性


<br />

8. 在软件的整个生命周期中，都需要创新. 但是我们会有这么一个误区: 需求迭代过程中我们会进行创新，毕竟迭代的时候会有新的功能点出来，但是等到软件进入维护阶段则不会进行创新了，但这是错误的，因为维护阶段不代表软件已经死了，只是该阶段的创新相比其他阶段会少一些，但不能说停止了


<br />

9. DDD的限界上下文的划分跟微服务的粒度的大小的定义很相似。 其实DDD中的一个限界上下文内可能包含多个微服务。微服务粒度的划分，没有一个标准答案，因为它是一个设计决策，微服务的粒度其实是团队做出的决策，在决定之前团队对它的粒度可以进行质疑探讨，毕竟这是一个架构设计。可以从以下几点去考虑自己的微服务粒度大小
  - 现有架构间的依赖关系
  - 业务的扩展性
  - 团队人员的能力
  - 最后是在实现期间可能会遇到的风险和挑战


<br />
<br />

<a name="7Vt1w"></a>
### chapter 3: 子域

<br />子域是一个小的功能领域，在java中就是一个package的划分。 在使用DDD时，理想情况下是一个限界上下文对应一个子域(1:1的关系)，因为这样可以让限界上下文的目标清晰并且专注于核心战略。如果必须在同一个界限上下文(核心域)中创建第二个模型，那么应该使用一个完全独立的模块将该模型从核心域中分离出来(在java中就是新建一个package)。<br />
<br />子域分为3中类型

- 核心域，这种类型的域是唯一的并且定义明确的领域模型，是团队甚至公司的区分其他竞争对手的核心所在，需要花大力气大资源去攻克的领域，是公司/团队的战略所在
- 支撑子域，这类领域通常是定制的，一般可复用性较差，可以花较少的精力去做
- 通用子域，这一类的领域通常是各个领域公共的，构建的时候主要需要考虑其稳定性和兼容性，不要影响到其他的域，毕竟是公用的


<br />他们之间的重要性: 核心域 > 支撑子域 > 通用子域。对于一个大泥球系统，可以尝试对其进行子域划分，这样可以把问题划分清除，方便后期进行改造迁移<br />
<br />

<a name="UzyMc"></a>
### chapter 4: 界限上下文之间的关系与交流

<br />界限上下文之间的关系，其实跟微服务之间的关系大同小异，它们之间的关系有:

- 合作关系。这种关系各个团队有共同的目标，大家步调一致。但是要注意的是合作要有一个期限，不能永久合作，因为只有设置了期限才能保持一个良性的合作，否则很可能到后面两个领域模型不区分彼此糅合在一起形成"大泥球"
- 共享内核。该关系意味着各个领域模型之间有交集，大家需要共建该交集。可以采用内部开源的方式进行共建(大家遵循一定的规范进行代码维护集成)
- 客户-供应商关系。该关系就是有一方需要依赖另一方提供的服务才能进一步业务展开，这时候
  - 作为服务提供方的服务需要注意在升级API的时候要做兼容
  - 使用方(客户方)，则需要遵循提供方的游戏规则进行玩耍，会有点被动；但好处是可以借助大树好乘凉，比如借助阿里云平台/amazon平台，快速搭建服务开展业务，缺点是很多产品只能使用所选云平台的服务
- 防腐层。每个界限上下文使用该层来隔离依赖领域的升级对自己领域的侵入，防腐层一般都会将依赖领域的业务术语翻译成自己领域内的业务语言，相同的也会将自己的业务语言转化为依赖领域的业务语言，充当一个翻译官的角色。这一层做好之后，可以在这一层上面做一层熔断降级，减少被依赖服务弄死的情况
- API模式
  - 改种模式跟 客户-供应商 关系类似
  - 服务与服务之间通过 API进行交流
  - API的提供方需要提供完备的 API文档以让使用方快速入手，很适合没有时间构建自己的防腐层的领域
- 各行其道。这种模式是DDD最希望看到的，就是各个领域各管各的，互不相干


<br />

<a name="noN1M"></a>
#### 领域之间的交流方式
跟微服务之间的沟通交流方式是一样的，分以下几种

- RPC，自己在TCP之上做了一层，用于各个服务的通信. 序列化基本都会自己做，适合数据块小的场景
- RESTful
  - REST就是把服务当作资源来使用了
  - 一般是HTTP协议进行，可以适配数据量大的场景，但是会由于HTTP封包/拆包，header过多等问题导致资源利用率不高的问题
  - 需要注意的是REST API的定义需要根据 调用方的需求来，而不是提供方想怎么就怎么样。因为提供方自己臆想出来的API可能根本满足不了调用方的需求
- 消息通知
  - 一般都是至少触达一次
  - 需要考虑
    - 重复消费时，保证业务的幂等
    - 对于消息延迟达到，需要在系统设计之处就考虑进去，做好相应的处理，保证系统的健壮性


<br />
<br />以上几种方式，都需要注意一点，就是避免连坐效应的发生:
```
A ---> B ---> C
```
由于B调用C慢导致A调用B被连坐，这里可以通过超时机制/异步机制等方式进行解决<br />
<br />
<br />在DDD模型中，通过 消息通知 进行上下文界限的沟通交流，一般是

- 通过领域模型中的 aggregate发布的Domain Event
- 感兴趣的领域会收到 Domain Event，进行自己的业务处理
- 由于可能会有多个consumer，所以发出的 Domain Event中的数据可以有两种
  - 肥胖型的Domain Event: 里面包含的数据内容涵盖大部分的consumer所需的数据
    - 这样会造成Domain Event中的数据很多
    - 数据多容易造成数据安全问题
    - 同时对传输带宽会形成压力
    - 对每个consumer来说也会有压力，因为可能当前consumer只想要Domain Event中的几个字段，其他的字段都是无用的。解析起来很费劲
  - 瘦弱型的: 只提供极精简的数据，各个consumer如果需要其他而外的数据，可以通过 事件源领域的API进行查看
    - 当然这样也会造成多次的领域间的通信，因为当consumer需要额外的数据时，就必须通过调用API的方式获取数据
    - 但对于大部分consumer来说，Domain Event中的基本数据是能满足它们的业务需求的
  - 具体选择 瘦子还是胖子，要根据自己的业务来定


<br />
<br />

<a name="t7UGf"></a>
### chapter 5: 聚合
聚合简单的理解，就是根据业务将一些相关的逻辑聚在一起，并且它们之间的状态会保持一致，所以一般来说一个聚合就是一个事务。聚合有几个重要的元素

- 实体，可以认为是一个数据的表示，但跟面向对象中的实体稍微会不一样，因为DDD中的实体其实是充血对象，里面除了属性之外，还会有行为
- 值对象，对，它们就是值，在生成之后就不变的东西，比如常量，或者是一个实体的id(生成之后是不会变的)


<br />每个聚合有一个根实体，该实体控制着聚合内的其他元素，一般聚合的名称就是按照根实体的名称来命名<br />
<br />
<br />聚合经验法则

- 在聚合边界内保护业务规则保持不变，即保持事务一致
  - 考虑的时候，将状态有关联性的东西放在一起，形成一个聚合
  - 提交的时候一起提交，保证各自的状态保持正确，不会错乱
  - 一般有个原则就是，需要即时响应发生的，放在一个聚合里。可以延时发生的，可以放到不同的聚合，通过领域事件保持最终一致性
- 聚合不要设计的太大，要尽量小，否则会变得很臃肿
  - 不要将两个实体放在一个聚合内，否则会将聚合撑大
- 不同聚合之间通信通过标识来引用
- 不同聚合之间，通过最终一致性来保持


<br />
<br />关于贫血模型: 对象中，只有Getter/Setter，没有其他的业务行为。一般的贫血模型，都是在外面进行业务设置，或者在工具类中进行业务处理. 这样的好处是: 保持对象的干净；坏处就是业务会散落在各处，会不好管理<br />
<br />充血模型，在DDD中会将业务都封装在对象中，这样业务管理比较方便。但对熟悉面向对象的朋友可能会不太好理解<br />
<br />

<a name="kkz3r"></a>
### chapter 6: 领域事件

<br />领域事件，是不同聚合沟通的桥梁。一般领域事件的触发有两种情况

- 由命令触发，所谓命令是由用户操作了某个动作而发出的指令。由命令触发而来的领域事件，在处理的时候可以根据业务需要拒绝处理
- 由于时间到了而触发，即时间领域事件。该类领域事件不能拒绝，必须无条件地进行处理


<br />
<br />领域事件的其他

- 一般领域事件的内容中都有一个sourceId，由于记录该事件的发起方是谁. 比如我们发送MQ消息的时候，也会这么干，这样有助于在处理的时候进行适当的分派；
- 领域事件的命名，一般通过命令来。并且是过去式. 比如命令叫: bookHotel, 那么事件的名称就是: hotelBooked
- 所谓事件溯源，就是将发生的事情都记录起来，方便后面排查只用。平时使用的记录表就能起到这种作用，这个也是要根据实际情况操作的，并不是所有的聚合都需要事件溯源的


<br />

<a name="3cd7Q"></a>
### chapter 7: 工具
事件风暴，就是快速的聚焦地分析问题->发现问题-> 找到方案-> 进而形成共识，主要步骤包括

- 将大家聚在一起(开发+测试+需求方)，快速对需求过一遍，然后找到核心的领域事件
- 针对找到的领域事件，定义触发这些领域事件的命令
- 将领域事件+命令，通过实体/聚合关联起来
- 然后将聚合的流转方向定义清楚，形成一个业务流
- 最后如果有需要，可以在业务流的基础上，创建一些视图，从而可以提供更宏观层面的东西.这一步个人理解是对业务的抽象，从而更能抓住业务核心，并且可以用它来评估是否符合公司战略


<br />
<br />

<a name="nlhgQ"></a>
#### 敏捷开发相关

- No Estimates(拒绝估算): 不是否定敏捷开发的开始阶段的估算所产生的价值，而是探索在持续改进的过程中是否有一些手段可以协助或者改善估算活动，从而更加聚焦于交付价值。实践者一般会在估算阶段减少可以用的估算值的数量，比如只提供 0.5/1/3的牌，这样每个估算的得分都会很低，然后再推动团队将每个 user story进行拆解，如果可以拆解的够细，那么当task足够小交付足够快时，就可以不用对其做估算了。这样做的目的是希望更加聚焦于价值交付，而非将时间精力浪费在估算环节
- 敏捷的核心是知识获取(Knowledge Acquisition)。 通过站会，通过快速迭代，通过回顾会议等形式，快速获取到团队遇到的问题，客户的反馈等知识，从而做调整进行下一个优化迭代


<br />

<a name="fp5Pf"></a>
#### SWOT
一种项目管理的方式，主要的思路是: 找到问题 --> 然后找到应对之策。一般会通过划分四个象限来明确各个领域的现状

- S: Strength，优势是什么
- W: Weakness，当前团队的弱点是什么. 这个不能隐藏的，否则将不自量力
- O: Opportunity， 当前的机遇是什么，这是要将力量集中起来去抓住它攻破的东西
- T: Threat, 威胁是什么，或者说障碍是什么


<br />通过分析S+W，可以对团队有一个清晰的认识。通过O+T可以知道面对的是什么，对处境及整体环境有一个较好的认知
